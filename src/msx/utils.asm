; ====================================================================================================
;
; utils.asm
;
; included from main.asm
;
; ====================================================================================================

SECTION code_user

; ====================================================================================================
; キー入力値取得サブルーチン
; @ToDo : 直前の入力値を退避するようにする（連射入力のため）
; ====================================================================================================
GET_CONTROL:
    CALL KILBUF                     ; BIOS キーバッファクリア
    OR A                            ; キャリーフラグクリア

    ; ■プレイヤー操作データ(STICK)を取得
    LD A,0                          ; A <- ジョイスティック番号=0(キーボード)
    CALL GTSTCK                     ; BIOS ジョイスティックの状態取得
                                    ; - Aレジスタに入力値が設定されている
    LD B,A                          ; B <- A

    PUSH BC                         ; BCレジスタを退避
    LD A,1                          ; A <- ジョイスティック番号=1(パッド1)
    CALL GTSTCK                     ; ジョイスティック入力取得
    POP BC                          ; BCレジスタを復帰
    OR B                            ; A=A OR B
                                    ; - キーボードとパッドの入力の OR を取る
                                    ;   最大で15となる

    LD (INPUT_BUFF_STICK), A        ; 現在の入力値を保存

    ; ■プレイヤー操作データ(STRIG)を取得
    LD D,0                          ; D <- 0
    LD A,0                          ; A <- ジョイスティック番号=0(キーボード)
    CALL GTTRIG                     ; BIOS トリガボタンの状態取得
                                    ; - $00 = 押されていない
                                    ; - $0FF = 押されている
    OR A
    JR Z,GET_CONTROL_L1
    LD D,1                          ; D <- 1

GET_CONTROL_L1:
    LD E,0                          ; E <- 0
    LD A,1                          ; A <- ジョイスティック番号=0(パッド1)
    CALL GTTRIG                     ; BIOS トリガボタンの状態取得
    OR A
    JR Z,GET_CONTROL_L2
    LD E,1                          ; E <- 1

GET_CONTROL_L2:
    LD A,D                          ; A=D OR E
    OR E                            

    LD (INPUT_BUFF_STRIG), A        ; 現在の入力値を保存

GET_CONTROL_EXIT:
    RET


; ====================================================================================================
; 文字列表示サブルーチン
; IN  : HL = 表示文字データの開始アドレス
; ====================================================================================================
PRTSTR:
    LD B,(HL)                       ; BC <- HLアドレスの示すオフセット値データ
    INC HL
    LD C,(HL)

    INC HL                          ; HL <- 文字列データの先頭アドレス
    PUSH HL                         ; HL -> DE
    POP DE

    LD HL,PTN_NAME_ADDR             ; HL <- パターンネームテーブルの先頭アドレス
    ADD HL,BC                       ; HL=HL+BC

PRTSTR_L1:
	LD A,(DE)				        ; AレジスタにDEレジスタの示すアドレスのデータを取得
	OR 0					        ; 0かどうか
    JR Z,PRTSTR_END			        ; 0の場合はPRTENDへ

	CALL WRTVRM				        ; BIOS WRTVRM呼び出し
	    					        ; - HL : 書き込み先のVRAMアドレス
    	                            ; - A  : 書き込むデータ

	INC HL					        ; HL=HL+1
    INC DE					        ; DE=DE+1
    JR PRTSTR_L1

PRTSTR_END:
	RET


; ====================================================================================================
; 16進数表示サブルーチン
; IN  : A = 表示対象データ
;       HL = 表示位置のVRAMアドレスオフセット値
; ====================================================================================================
PRTHEX:
    PUSH AF
    ; ■VRAMアドレス算出
    LD DE,HL                        ; DE <- HL
    LD HL,PTN_NAME_ADDR             ; HL <- パターンネームテーブルの先頭アドレス
    ADD HL,DE                       ; HL=HL+DE

    ; ■表示対象データの上位4ビットに対する表示文字コード算出
    PUSH AF                         ; AFレジスタを一旦スタックに退避
    SRL A                           ; 右シフトx4
    SRL A
    SRL A
    SRL A
    CALL PRTHEX_GETCHR              ; Aレジスタの値からキャラクタコードを求める

    ; ■VRAM書き込み
    CALL WRTVRM

    ; ■VRAMアドレスをインクリメント
    INC HL

    ; ■表示対象データの下位4ビットに対する表示文字コード算出
    POP AF                          ; AFレジスタをスタックから復帰
    AND @00001111                   ; 下位4ビットを取り出し
    CALL PRTHEX_GETCHR              ; Aレジスタの値からキャラクタコードを求める

    ; ■VRAM書き込み
    CALL WRTVRM

PRTHEX_EXIT:
    POP AF
    RET

PRTHEX_GETCHR:
    OR A                            ; キャリーフラグリセット
    CP 10                           ; A < 10の場合はキャリーフラグが立つ
    JR C,PRTHEX_GETCHR_L1
    ADD A,$37                       ; A〜F
    RET

PRTHEX_GETCHR_L1:
    ADD A,$30                       ; 0〜9
    RET


; ====================================================================================================
; 絶対値減算サブルーチン
; IN  : A = 値１
;       B = 値２
; OUT : A = A-Bの絶対値
; ====================================================================================================
ABS_SUB:
    OR A
    SUB B                           ; A=A-B
    JP M,ABS_SUB_L1                 ; マイナスだったらABS_SUB_L1へ
    RET

ABS_SUB_L1:
    NEG                             ; 上記の結果を正負反転
	ADD A,$FF                       ; A=A+$FF
    ADD A,1                         ; さらに1加算して一巡させる
    RET


; ====================================================================================================
; アドレステーブルからのデータ取得サブルーチン
; IN  : HL = アドレステーブルのアドレス
;       A = 要素数(0～)
; OUT : DE = アドレステーブルから取得したデータ
; ====================================================================================================
GET_ADDR_TBL:
    RLCA                            ; A=A*2
    LD D,0                          ; DE <- アドレスのオフセット値
    LD E,A

    ADD HL,DE                       ; HL=HL+DE

    LD E,(HL)                       ; DE <- テーブルの値
    INC HL
    LD D,(HL)

GET_ADDR_TBL_EXIT:
    RET


; ====================================================================================================
; アドレステーブルによるジャンプ処理
; ジャンプ先の処理でRETすると、ここの処理に戻ってきます。
; IN  : HL = 対象テーブルの先頭アドレス
;       A = インデックスNo(0～)
; ====================================================================================================
TBL_JP:
    CALL GET_ADDR_TBL               ; アドレステーブルからデータ取得

    LD HL,TBL_JP_EXIT               ; 戻り先のアドレスをスタックに設定
    PUSH HL

    EX DE,HL                        ; HL <-> DE

    JP (HL)

TBL_JP_EXIT:
    RET


; ====================================================================================================
; 乱数初期化サブルーチン
; ====================================================================================================
INIT_RND:
    LD A,(INTCNT)
    LD (RND_WK),A                   ; 乱数のシード値を設定

INIT_RND_EXIT:
    RET


; ====================================================================================================
; 乱数取得サブルーチン
; 事前にINIT_RNDを実行しておくこと
; OUT : A = 0〜255の範囲の乱数
; ====================================================================================================
GET_RND:
    PUSH BC
    
    LD A,(RND_WK)                   ; 乱数のシード値を乱数ワークエリアから取得
    LD B,A
    LD A,B

    ADD A,A                         ; A=A*5
    ADD A,A                         ;
    ADD A,B                         ;

    ADD A,123                       ; 123を加える
    LD (RND_WK),A                   ; 乱数ワークエリアに保存

GET_RND_EXIT:
    POP BC
    RET


; ====================================================================================================
; 画面クリアサブルーチン
; HL,BC,Aレジスタを破壊します
; ====================================================================================================
SCREEN_CLRAR:
    LD HL,$1800+32*2                ; 書き込み開始アドレス
    LD BC,32*22                     ; 書き込みデータ長
    LD A,$20                        ; 書き込むデータ
    CALL FILVRM                     ; BIOS VRAM指定領域同一データ転送

SCREEN_CLRAR_EXIT:
    RET


SECTION bss_user
; ====================================================================================================
; ワークエリア
; プログラム起動時にcrtでゼロでramに設定される 
; ====================================================================================================

; ■乱数ワークエリア
RND_WK:
    DB 0
